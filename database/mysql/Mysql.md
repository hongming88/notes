# 逻辑架构

<img src="..\..\pics\database\Mysql\逻辑架构2.png" style="zoom:45%;" />

<img src="..\..\pics\database\Mysql\逻辑架构.png" style="zoom:75%;" />



## 连接层

<font color="red">**每一个客户端发起一个新的请求都由服务器端的连接/线程处理工具负责接收客户端的请求并开辟一个新的内存空间，在服务器端的内存中生成一个新的线程，当每一个用户连接到服务器端的时候就会在进程地址空间里生成一个新的线程用于响应客户端请求，用户发起的查询请求都在线程空间内运行， 结果也在这里面缓存并返回给服务器端**</font>。线程的重用和销毁都是由连接/线程处理管理器实现的。

　　综上所述：用户发起请求，连接/线程处理器开辟内存空间，开始提供查询的机制。


最上层是一些客户端和连接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在**该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程**。同样在该层上可以实现基于SSL 的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。



可以通过如下命令查看连接配置信息：`SHOW VARIABLES LIKE '%connect%';`可以看到最大连接和每个连接占用的内存等相关配置。



## 服务层

| Management Serveices & Utilities | 系统管理和控制工具                                           |
| -------------------------------- | ------------------------------------------------------------ |
| SQL Interface:                   | 接口。接受用户的SQL 命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface |
| Parser                           | 解析器。SQL 命令传递到解析器的时候会被解析器验证和解析       |
| Optimizer                        | 查询优化器。SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有where 条件时，优化器来决定先投影还是先过滤。 |
| Cache 和Buffer                   | 查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等 |

## 引擎层
存储引擎层，存储引擎真正的负责了MySQL 中数据的存储和提取，服务器通过API 与存储引擎进行通信。不同
的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。

可以通过下面两个命令查看MySQL当前版本，和对存储引擎的支持情况。

```sql
SELECT VERSION() ; SHOW ENGINES ;
```



## 存储层
数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。



## **MySQL查询过程**

<img src="..\..\pics\database\Mysql\查询过程.png" style="zoom:44%;" />



参考连接：https://blog.csdn.net/fuzhongmin05/article/details/70904190



## MyISAM 和InnoDB



| 对比项         |                          MyISAM                          |                            InnoDB                            |
| -------------- | :------------------------------------------------------: | :----------------------------------------------------------: |
| 外键           |                          不支持                          |                             支持                             |
| 事务           |                          不支持                          |                             支持                             |
| 行表锁         | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁,操作时只锁某一行，不对其它行有影响，**适合高并发**的操作 |
| 缓存           |                只缓存索引，不缓存真实数据                | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 关注点         |                          读性能                          |                      并发写、事务、资源                      |
| 默认安装       |                            Y                             |                              Y                               |
| 默认使用       |                            N                             |                              Y                               |
| 自带系统表使用 |                            Y                             |                              N                               |



# 索引

## 索引是什么

**MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。**

索引的目的在于提高查询效率，可以类比字典。

如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。

如果没有索引，那么你可能需要逐个逐个寻找，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？

是不是觉得如果没有索引，这个事情根本无法完成？

你可以简单理解为“排好序的快速查找数据结构”。



详解：

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是**一种可能的索引方式**示例：


![](..\..\pics\database\Mysql\索引1.jpg)



左边是**数据表**，一共有两列七条记录，最左边的是数据记录的**物理地址**。

为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。

**数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。**

<font color="red">一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</font>

==我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。==其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。

## 索引优劣势

**优势**

- 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本。

- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

**劣势**

- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的（占空间）

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。**因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息**。

- 索引只是提高效率的一个因素，如果你的MysQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。

**总结**

- 索引，空间换取时间。



## 索引分类和建索引命令语句

**MySQL索引分类：**

- 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。
- 唯一索引：索引列的值必须唯一，但允许有空值。
- 主键索引:设定为主键后数据库会自动建立索引，innodb为聚簇索引
- 复合索引：即一个索引包含多个列。
- 基本语法：
  

| 操作                                       | 命令                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 创建                                       | - `CREATE [UNIQUE] INDEX indexName ON mytable(columnName(length));`<br/>- `ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnName(length));` |
| 删除                                       | `DROP INDEX [indexName] ON mytable;`                         |
| 查看                                       | `SHOW INDEX FROM tableName;`                                 |
| 使用alter命令 有四种方式来添加数据表的索引 | `ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);`：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 |
|                                            | `ALTER TABLE tbl name ADD UNIQUE index_name (column_list);`：这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。 |
|                                            | `ALTER TABLE tbl_name ADD INDEX index_name (column_list);`：添加普通索引，索引值可出现多次。 |
|                                            | `ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);`：该语句指定了索引为FULLTEXT，用于全文索引。 |



## 索引的创建时机
 **适合创建索引的情况**

- 主键自动建立唯一索引；

-  频繁作为查询条件的字段应该创建索引

-  查询中与其它表关联的字段，外键关系建立索引

- 单键/组合索引的选择问题， 组合索引性价比更高

- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度

- 查询中统计或者分组字段

  

**不适合创建索引的情况**

- 表记录太少
- 经常增删改的表或者字段

# Explain 性能分析

## 性能分析前提知识

**MySQL Query Optimizer**

- **Mysql中有专门负责优化SELECT语句的优化器模块**，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的,这部分最耗费时间）

- 当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query 中的 Hint信息(如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint 或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。

**MySQL常见瓶颈**

- `CPU`：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
- `IO`：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
- 服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态
  

## **explain使用简介**
使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。

[官网地址](https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html)

**能干嘛**

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询
  

**怎么玩**

`explain + sql语句`

执行计划包含的信息
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |

例如：

```sql
mysql> select * from tbl_dept;
+----+----------+--------+
| id | deptName | locAdd |
+----+----------+--------+
|  1 | RD       | 11     |
|  2 | HR       | 12     |
|  3 | MK       | 13     |
|  4 | MIS      | 14     |
|  5 | FD       | 15     |
+----+----------+--------+
5 rows in set (0.00 sec)

mysql> explain select * from tbl_dept;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | tbl_dept | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

```



## explain之id介绍

select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序

三种情况：

- id相同，执行顺序由上至下
- id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
- id相同不同，同时存在



①**id相同，执行顺序由上至下**

![](..\..\pics\database\Mysql\explain_id1.jpg)

②**id 不同，id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行**

![](..\..\pics\database\Mysql\explain_id2.jpg)

③id 如果相同，可以认为是一组，从上往下顺序执行；**在所有组中，id 值越大，优先级越高**，越先执行衍生= DERIVED

![](..\..\pics\database\Mysql\explain_id3.jpg)

关注点：<font color="red">id 号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</font>

## explain之select_type和table介绍

**select_type**：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。

**select_type有哪些？**

1. `SIMPLE` - 简单的select查询,查询中不包含子查询或者UNION。
2. `PRIMARY` - 查询中若包含任何复杂的子部分，最外层查询则被标记为。
3. `SUBQUERY` - 在SELECT或WHERE列表中包含了子查询。
4. `DERIUED` - 在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQ会递归执行这些子查询，把结果放在临时表里。
5. `UNION` - 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中外层SELECT将被标记为：DERIVED。
6. `UNION RESULT` - 从UNION表获取结果的SELECT。


**table**：显示这一行的数据是关于哪张表的。

## explain之type介绍
访问类型排列

type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：

system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index >ALL



<font color="red">从最好到最差以此是</font>:

system>const>eq_ref>ref>range>index>ALL



**详细说明**

- `system`：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。
- `const`：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量。
- `eq_ref`：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
- `ref`：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
- `range`：只检索给定范围的行,使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
- `index`：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。
- `all`：Full Table Scan，将遍历全表以找到匹配的行。



<font color="red">一般来说，得保证查询至少达到range级别，最好能达到ref。</font>

## explain之possible_keys和key介绍
**possible_keys**

显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段火若存在索引，则该索引将被列出，==但不一定被查询实际使用==。

**key**

**实际使用的索引**。如果为NULL，则没有使用索引

**查询中若使用了覆盖索引，则该索引仅出现在key列表中**

## explain之key_len介绍

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 字段能够帮你检查是否充分的 利用上了索引。ken_len 越长，说明索引使用的越充分。在不损失精确性的情况下，长度越短越好

key_len显示的值为索引字段的最大可能长度，**并非实际使用长度**，即key_len是根据表定义计算而得，不是通过表内检索出的



**如何计算**：
①先看索引上字段的类型+长度比如`int=4 ; varchar(20) =20 ; char(20) =20`
②如果是varchar 或者char 这种字符串字段，视字符集要乘不同的值，比如utf-8 要乘3,GBK 要乘2，
③varchar 这种动态字符串要加2 个字节
④允许为空的字段要加1 个字节

## explain之ref介绍

**显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。**



查询中与其它表关联的字段，外键关系建立索引。

## explain之rows介绍

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。

rows 列显示MySQL 认为它执行查询时必须检查的行数。越少越好！

## explain之Extra介绍

包含不适合在其他列中显示但十分重要的额外信息。

**Using filesort**（九死一生）

说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<font color="red">MySQL中无法利用索引完成的排序操作称为"文件排序"</font>



**Using temporary**（不好）

使了用临时表保存中间结果，MysQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。

**Using index**

表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！

如果同时出现using where，表明索引被用来执行索引键值的查找；

如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。



**覆盖索引**（Covering Index）,一说为索引覆盖。

- 理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。

- 理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。

- 注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select*，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。



**Using where**

表明使用了where过滤。



**Using join buffer**

使用了连接缓存。



**impossible where**

where子句的值总是false，不能用来获取任何元组。



**select tables optimized away**

在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。



**distinct**

优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。


## explain之热身Case

![](..\..\pics\database\Mysql\explain_Case.png)

第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。`【select d1.name… 】`

第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。`【select id,namefrom t1 where other_column=’’】`

第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。`【select id from t3】`

第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行`【select name,id from t2】`

第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的<union1,4>表示用第一个和第四个select的结果进行union操作。`【两个结果union操作】`


## 总结

id,type,key,rows Extra最重要了

































