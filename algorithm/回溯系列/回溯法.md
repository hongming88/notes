# 回溯法
## 文字版
**理解为什么是深度优先遍历，和回溯又有什么关系**

深度优先遍历在编码上可以使用栈或者递归实现，`当使用递归时就叫做回溯法`。

下面我们解释一下上面的树形结构，请大家**从深搜在这棵树上走过的路径**来理解以下的几点说明：

1、**每一个结点表示了“全排列”问题求解的不同阶段，这些阶段通过变量的“不同的值”体现**，这些变量的不同的值，称之为“状态”；


2、**深度优先遍历由于有“回头”的过程**，在“回头”以后，状态变量需要设置成为和先前一样。在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”，**“状态重置”就是“回溯”的本意**；

3、使用深度优先遍历编写代码，可以直接借助系统栈空间，为我们保存所需要的状态变量。在编码中需要注意：遍历到相应的结点的时候，状态变量的值是必须是正确的。此处我们来认识 `path` 变量作为状态变量，它在深度优先遍历中的变化：往下走一层的时候，`path` 变量在尾部追加一个数字，而往回走的时候，**需要撤销上一次的选择**，这一操作也是在 `path` 的尾部去掉一个数字，因此 `path` 变量是一个栈。



**如何编码：**

1、首先这棵树除了叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提下，==需要在剩下还没有选择的数中按照顺序依次选择一个数==，这显然是一个递归结构；

2、递归的终止条件是，数字的个数已经选够了，因此我们需要一个变量来表示当前已经选了几个数字，即当前递归到第几层，我们把这个变量叫做 `depth`；

3、这些结点实际上表示了搜索全排列问题的不同阶段，为了区分这些不同阶段，我们就需要一些变量来记录为了得到一个全排列，程序进行到哪一步，在这里我们需要两个变量：

（1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列，`path` 就是这样的变量；
（2）一个布尔数组 `used`，初始化的时候都为 `false`，表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 `true` ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。

这两个变量称之为“状态变量”，它们 **表示了我们在求解一个问题的时候所处的阶段** 。

4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。

5、另外，由于执行的深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子：**请大家看上面的树形图想象**，代码是如何从叶子结点 `[1, 2, 3]` 到叶子结点 `[1, 3, 2]` 的。深度优先遍历是这样执行的：

- 从 `[1, 2, 3]` 回到 `[1, 2]` 的时候，需要撤销刚刚已经选择的数 `3`；
- 由于在上一层只有一个数 `3` 能选择，我们已经尝试过了，因此程序回到再上一层，需要撤销对 `2` 的选择，好让后面的程序知道，选择 `3` 了以后还能够选择 `2`。

> 希望大家能通过在脑子里实际地像代码一样走一遍深度优先遍历的过程，去理解代码应该怎样写。或者直接看后面的代码，然后去理解代码为什么要这样写。事实上，我是先学习，然后再理解。





## 子集树写法